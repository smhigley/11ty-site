<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sarah Higley</title>
	<subtitle></subtitle>
	<link href="https://sarahmhigley.com/feed.xml" rel="self"/>
	<link href="https://sarahmhigley.com/"/>
	<updated>2019-11-03T18:00:00-06:00</updated>
	<id>https://sarahmhigley.com</id>
	<author>
    <name>Sarah Higley</name>
	</author>
	
  
  <entry>
    <title>Tooltips in the time of WCAG 2.1</title>
    <link href="https://sarahmhigley.com/writing/tooltips-in-wcag-21/"/>
    <updated>2019-08-16T19:00:00-05:00</updated>
    <id>https://sarahmhigley.com/writing/tooltips-in-wcag-21/</id>
    <content type="html"><![CDATA[
      <p>TL;DR recommendation: Narrow down your definition of &quot;tooltip,&quot; and jump to <a href="#best-practices-summary">the last section</a>.</p>
<p>Tooltips have been a reliable source of web accessibility woes from the very beginning; or at least from the beginning of graphical web browsers. They have gone by many names: &quot;tooltip,&quot; &quot;infotip,&quot; &quot;toggle tip,&quot; &quot;hint text,&quot; &quot;balloon help,&quot; &quot;info bubble,&quot; &quot;inaccessible overlay of shame&quot;... the list goes on. No matter the name, the same core issues just keep popping up:</p>
<ul>
<li>How do keyboard users access the content?</li>
<li>How do non-mouse pointers (e.g. touchscreens and eye trackers) access the content?</li>
<li>How do blind and low vision users even know the tooltip is there, let alone read it?</li>
<li>If (Internet Lords forbid) there is interactive content inside, how does one access it without accidentally dismissing the tooltip?</li>
<li>How does a user with magnification software move their field of view to read the tooltip without accidentally dismissing it?</li>
</ul>
<h2 id="so-why-do-tooltips-have-so-many-problems%3F">So why do tooltips have so many problems?</h2>
<p>The first hint of a graphical tooltip on the web came in an <a href="https://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt">early draft of HTML</a> when &quot;title&quot; appeared as an optional attribute on links with the following note:</p>
<blockquote>
<p>The browser software may chose to display the title of the document as a preliminary to retrieving it, for example as a margin note or on a small box while the mouse is over the anchor, or during document fetch.</p>
</blockquote>
<p>At the time that spec was written, graphical <a href="https://en.wikipedia.org/wiki/OutSpoken">screen readers had already existed for over four years</a>. Now, 26 years in the future, we're doing a little bit better. The same inaccessible mouse-based <code>title</code> behavior exists, but at least the <a href="https://html.spec.whatwg.org/multipage/dom.html#the-title-attribute">latest version of the HTML spec</a> explicitly calls out the accessibility problems while warning against using it. Also, <a href="https://www.w3.org/TR/WCAG21/">WCAG</a> is a thing now. But back in the earlier days of the web, it was open season on defining experiences solely for sighted mouse users.</p>
<p>The <a href="http://1997.webhistory.org/www.lists/www-talk.1993q1/0182.html">image tag was first proposed</a> by a browser representative (from Mosaic, since this happened in 1993) as <a href="https://thehistoryoftheweb.com/the-origin-of-the-img-tag/">more of an advance notice than a suggestion</a>. Although the alt attribute was included in the <code>img</code> specification from the very start, <a href="http://jkorpela.fi/html/alt.html#old">practical support was slow</a> and for years screen readers and text-only browsers had no good way of communicating a graphic.</p>
<p>If the history of the image tag seems like an odd digression for an article about tooltips, the reason lies in what happened next: browsers began to actually implement the alt attribute, but they chose to <a href="http://jkorpela.fi/html/altshow.html#tooltip">visually display it as a tooltip</a>, just like the <code>title</code> attribute on links. Although <code>alt</code> still functioned as a text alternative, the tooltip implementation changed how website authors wrote alt text content. There are articles written about the <a href="http://jkorpela.fi/html/alt.html#tooltip">harmful effect of the tooltip treatment</a> as well a <a href="http://www.alanflavell.org.uk//alt/alt-text.html#howlers">compilation of hilarious examples</a> of real live alt text from that time (imagine image after image with the alt text &quot;Click here!&quot;).</p>
<p>Although alt text no longer gets the tooltip treatment in any modern browser, looking back at that era illustrates a deeper issue with the design itself. From the very beginning, the behavior of a native tooltip has made it easy to create content solely for mouse users with good vision while forgetting about everyone else. The alt text tooltip directly demonstrated how easily that type of design can degrade the experience for anyone relying on non-mouse-based interaction or assistive tech. Continuing problems caused by the title attribute's non-inclusive tooltip have also been thoroughly documented (try this wonderfully comprehensive <a href="https://www.24a11y.com/2017/the-trials-and-tribulations-of-the-title-attribute/">24a11y article by Scott O'Hara</a> for a start).</p>
<h2 id="beyond-the-title-attribute%3A-what-are-tooltips-now%3F">Beyond the title attribute: what are tooltips now?</h2>
<p>Usually &quot;use native controls&quot; is the mantra of accessibility professionals, so if the native tooltip is flawed all the way down to its very design, where does that leave designers and developers? The short answer is out in the rain without a popup (or &quot;umbrella&quot; for those who live in the real world) for shelter.</p>
<p>Before diving into the details of how to implement a custom tooltip, let's take a moment to define what a tooltip really <em>is</em>. Conventionally, the term has referred to a purely visual treatment: text that appears in a small overlay on demand, usually when hovering over the thing it describes. This presents a problem when trying to create a specification for a consistent, accessible experience, since visual patterns do not always have a one-to-one relationship with interaction patterns.</p>
<p><em>(Wait. What?)</em></p>
<p>A major pitfall of approaching web design as a visual medium is conflating <em>visual</em> patterns with <em>functional</em> or <em>interaction</em> patterns. One classic example of this is that the word &quot;menu&quot; in web UI has acquired both a broad, generic meaning as well as a specific and technical one. In what passes for casual conversation among web professionals, the word &quot;menu&quot; might refer to a set of links used as site navigation, the file/edit/etc. bar of actions along the top of most applications, or a list of appetizers printed on paper at a restaurant.</p>
<p>Leaving off that last one, keyboard and assistive tech users expect a navigation menu and traditional application menu to function differently: a navigation menu is a list of links that is tabbed through, and an application menu is a collection of menu actions that are reached by arrow keys and often shortcuts. One visual pattern, multiple interaction patterns. To go further down that particular rabbit hole, try this shot: <a href="https://inclusive-components.design/menus-menu-buttons/">inclusive-components.design/menus-menu-buttons</a> followed by this chaser: <a href="https://github.com/w3c/aria-practices/issues/353">github.com/w3c/aria-practices/issues/353</a>.</p>
<p><em>(Back to tooltips)</em></p>
<p>Much like &quot;menu,&quot; the word &quot;tooltip&quot; has come to mean nearly any small, non-modal overlay. While the most traditional use is to provide simple hint text for UI controls (tips for tools, after all), the same visual pattern could be used to display a text alternative for an icon button, a form error message, rich text content (e.g. bold text or a list), or even interactive content. Although all of these use cases could share the same base implementation if visual presentation and mouse interaction were all that mattered, the differences are important for accessibility for the following reasons (in order):</p>
<ol>
<li>Hint text is purely supplemental, and should not override the existing accessible name for a control.</li>
<li>The text alternative for an icon button is its accessible name, and should be associated with the button accordingly.</li>
<li>Rich text formatting can not be conveyed through the usual means of associating hint text with a control (namely <code>aria-describedby</code>).</li>
<li>Interactive content within a popup introduces a whole new set of requirements. It must be easily discoverable by screen readers, follow a logical tab order, be easy to access without dismissing the tooltip and without relying on fine motor control.</li>
</ol>
<p>There is no single DOM structure or javascript implementation that could fill all the requirements of even the few use cases mentioned here, so for the purposes of arriving at some sort of concrete recommendation, popups with rich or interactive content are not considered tooltips. Those patterns would benefit from using a <a href="https://www.w3.org/TR/wai-aria-practices-1.1/#disclosure">disclosure button pattern</a> under the hood. Similarly, a tooltip-style popup that is not tied to an existing interactive control would also benefit from the disclosure pattern. This would prevent it from spawning a useless button purely for the purpose of introducing a tab stop for keyboard access.</p>
<p>With those out of the way, let's take a stab at writing a visually-agnostic spec for a tooltip. The rest of the article, particularly the accessibility recommendations, will assume that a tooltip fits the following definition:</p>
<blockquote>
<p>A &quot;tooltip&quot; is a non-<a href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal">modal</a> (or non-blocking) overlay containing text-only content that provides supplemental information about an existing UI control. It is hidden by default, and becomes available on hover or focus of the control it describes.</p>
</blockquote>
<p>That definition could even be narrowed down even further by saying tooltips must provide only descriptive text -- essentially defining it as a custom, accessible version of the title attribute -- but all of the same interaction requirements apply whether the tooltip is used to display a name, description, or error message even if the semantics differ slightly.</p>
<h2 id="the-accessibility-requirements-of-tooltips">The accessibility requirements of tooltips</h2>
<p>Tooltips must be discoverable and readable with a mouse, other pointer devices, keyboard, screen reader, zoom software, and any other assistive technology. They should provide relevant information that may be helpful to learn the UI, but is not required to operate it. Tooltips also should not block a user from performing any other task on the screen.</p>
<p>Not so complicated, right? Let's dive into some of the specifics, broken down into semantics, interaction, and content.</p>
<h3 id="semantics">Semantics</h3>
<p>Meaningful semantics form the backbone of good HTML structure, and help screen readers and other assistive tech provide so many helpful shortcuts for moving around an interface. Headings are headings, links are links, accordions let you know if they are expanded or collapsed, and tooltips are... what exactly?</p>
<p>As described in detail earlier, tooltips can be used for a number of purposes. Even in our stripped-down definition, they could function as a name or a description, and the semantics would be different for each. The trick is to first decide what purpose the tooltip text has, and then assign semantics accordingly.</p>
<h4>Descriptive tooltip semantics</h4>
<p>For the most canonical tooltip purpose -- hint text -- the only two semantic additions are:</p>
<ol>
<li>associate the tooltip trigger with the tooltip via <code>aria-describedby</code> and <code>id</code></li>
<li>ensure the tooltip is unreachable when hidden via <code>aria-hidden</code></li>
</ol>
<p>A full HTML snippet for a sample text field asking for a name, with hint text in a tooltip follows. This HTML snapshot assumes the tooltip is in an open state.</p>
<pre class="language-html"><code class="language-html"><span class="highlight-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Full Name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span></span><br><span class="highlight-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">aria-describedby</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-hint<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span><br><span class="highlight-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-hint<span class="token punctuation">"</span></span> <span class="token attr-name">aria-hidden</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span><br><span class="highlight-line">  Please enter your given name followed by your family name</span><br><span class="highlight-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></span></code></pre>
<h4>Label tooltip semantics</h4>
<p>Using a tooltip as the accessible name is similar; instead of <code>aria-describedby</code>, the association would be made with <code>aria-labelledby</code>, and the tooltip container would not necessarily need <code>aria-hidden</code>. It is also possible to drop <code>aria-labelledby</code> entirely and have the tooltip text be a child of the control (at least for controls that support children). The main caveat for the name use case is that UI controls should always have some sort of label visible. This technique would not replace the need for a visible label next to an input, for example. A good use would be to add a text alternative for icon buttons.</p>
<h4>Semantics to avoid</h4>
<p>There are certain attributes that are missing in the above descriptions that the more ARIA-conscious may have already noticed. In no particular order, these are some accessibility-related attributes that may seem relevant, but are not currently recommended:</p>
<ul>
<li><code>role=&quot;tooltip&quot;</code>: the unloved child of roles, this omission is perhaps the weirdest in an article specifically about tooltips. While it's not a <em>bad</em> idea to add it to the tooltip element, it doesn't seem to do much good either. The <code>tooltip</code> role does not appear to affect screen reader announcements in any meaningful way -- <code>aria-describedby</code> and <code>aria-labelledby</code> do all the heavy lifting. If you do decide to add it, use it only for descriptive tooltips along with <code>aria-describedby</code>. There is more context in this Github thread: <a href="https://github.com/w3c/aria/issues/979">github.com/w3c/aria/issues/979</a></li>
<li><code>aria-haspopup</code>: although a tooltip may visually look like a popup, this attribute is for more interactive popups -- specifically only menus, listboxes, trees, grids, and dialogs are allowed in conjunction with <code>aria-haspopup</code>. Using a generic value of <code>aria-haspopup=&quot;true&quot;</code> will be interpreted as if it were <code>aria-haspopup=&quot;menu&quot;</code>. Since tooltips are not intended to be interacted with or navigated to, <code>aria-haspopup</code> should not be used to indicate a tooltip.</li>
<li><code>aria-live</code>: as the ultimate fallback for communicating any sort of dynamic page change, <code>aria-live</code> can be a tempting solution to complaints of tooltip text not being read by screen readers. However, live regions have some significant drawbacks for tooltip use: they can not be reliably re-read by a screen reader user, they may interrupt other content (e.g. announcing the name of the control on focus), and a screen reader user can't opt out of hearing them. It's true that <code>aria-describedby</code> may or may not be announced depending on a number of factors including user-selected verbosity settings, but that is the desired behavior for hint text.</li>
</ul>
<h3 id="interaction">Interaction</h3>
<p>The interaction support for displaying, hiding, and reading the tooltip content is the same whether the tooltip is used for a control's name or description.</p>
<h4>Focus and hover</h4>
<p>The first step is to ensure that the visual display can be controlled by either a keyboard or a mouse. To do this, the tooltip should open on focus or mouse over, and closes on blur or mouse out. Combining pointer and keyboard events should not create multiple tooltips or other buggy behavior. Since the UI control associated with the tooltip presumably has some sort of default action on click/enter or space/input, those interactions are not available for use in displaying or hiding the tooltip. If the UI control does not perform any actions or accept user input, it probably shouldn't have a tooltip at all (see the <a href="https://www.w3.org/TR/wai-aria-practices-1.1/#disclosure">disclosure button pattern</a> instead).</p>
<h4>Pointer (lack of) access</h4>
<p>Now that phone browsing has taken over, providing touch access has become imperative and this also benefits users of other non-mouse pointer device such as eye trackers. Unfortunately, one of the major drawbacks to tooltips is that they are inaccessible to touch devices when attached to buttons or links. This is because hover is unavailable on a touch device, and it is also impossible to focus a button or link without activating it. The same limitation exists for other pointer-controlled assistive tech like eye gaze. There is currently no workaround, although tooltips on form inputs will still work as expected.</p>
<h4>WCAG 2.1: dismissable, hoverable, and persistent</h4>
<p>One of the rules added in the Web Content Authoring Guildelines (WCAG) update from 2.0 to 2.1 is the <a href="https://www.w3.org/WAI/WCAG21/Understanding/content-on-hover-or-focus.html">1.4.13: Content on Hover or Focus</a> criterion. This new guideline expands the work required to make a compliant tooltip, but should make overlays in general significantly more accessible and less disruptive. WCAG 2.1 requires any content appearing on hover or focus to be dismissable, hoverable, and persistent.</p>
<p>To achieve those, a tooltip should:</p>
<ul>
<li>Hide when a keyboard user presses &quot;Escape&quot; (unless the tooltip will never overlap other content).</li>
<li>Allow a mouse or pointer user to hide the tooltip, ideally through a close button (unless the tooltip will never overlap other content). The tooltip should not re-appear on subsequent hovers -- think of a zoom user trying to center their view on a specific area without triggering the tooltip and obscuring content.*</li>
<li>Allow a mouse user to move their mouse over the tooltip content without dismissing the tooltip -- ideally in a manner that does not require laser focus and precision mouse control.</li>
<li>Remain in view until the user actively dismisses it, or it is no longer valid (e.g. if a loading tooltip appeared, then it could disappear after the content loaded).</li>
</ul>
<p>An extra note for those who closely read WCAG: &quot;unless the tooltip will never overlap other content&quot; is less of an exception than it appears. Even if a tooltip does not appear to overlay other content at a certain screen size, it may do so at a different screen size or level of zoom.</p>
<p>(*) An even more nitpicky side note: WCAG 1.4.13 says that a tooltip should be dismissable &quot;without moving pointer hover or keyboard focus,&quot; then goes on to suggest the Escape key to fulfill this requirement. This makes sense for keyboard users, but not at all for mouse users. On a usability level, people who primarily rely on a mouse or pointer are less likely to know keyboard shortcuts, and may not be able to use them. On a technical level, it is impossible to capture an escape press on a control that is hovered but not focused. A global escape listener would not be able to differentiate between a user wanting to dismiss a tooltip vs. close a dialog, if one were open. In short, the only feasible solution is to provide both keyboard and pointer methods of dismissal.</p>
<h3 id="content">Content</h3>
<p>Tooltips should only ever contain non-essential content. The best approach to writing tooltip content is to always assume it may never be read. As mentioned above, touch devices and other alternative pointers can't reach tooltips on buttons or links, and screen readers sometimes ignore descriptive text by default. It should be possible to infer how to use the UI without reading any tooltips. If that is not the case, it would be best to move all necessary content out of tooltips and into an area with more robust access and discoverability.</p>
<p>In addition to writing only supplemental content, the following should also be true:</p>
<ul>
<li><strong>Write concise tooltip text.</strong> Imagine someone on a small screen or with high zoom needing to pan around just to read the tooltip.</li>
<li><strong>Avoid rich content.</strong> Formatting such as bold text, italics, headings, icons, etc. will not be conveyed through <code>aria-describedby</code> or <code>aria-labelledby</code>.</li>
<li><strong>No interactive content.</strong> Any interactive content such as links or buttons should not be placed within a tooltip.</li>
</ul>
<h2 id="best-practices-summary">Best practices summary</h2>
<ul>
<li>Only interactive elements should trigger tooltips</li>
<li>Tooltips should directly describe the UI control that triggers them (i.e. do not create a control purely to trigger a tooltip)</li>
<li>Use <code>aria-describedby</code> or <code>aria-labelledby</code> to associate the UI control with the tooltip. Avoid <code>aria-haspopup</code> and <code>aria-live</code></li>
<li>Do not use the <code>title</code> attribute to create a tooltip</li>
<li>Do not put essential information in tooltips</li>
<li>Provide a means to dismiss the tooltip with both keyboard and pointer</li>
<li>Allow the mouse to easily move over the tooltip without dismissing it</li>
<li>Do not use a timeout to hide the tooltip</li>
</ul>
<p>If this article leaves you hungry for more tooltip drama and intrigue, never fear. You can continue your journey into tooltip mastery by perusing any of the links under &quot;Further reading.&quot; Also: get involved! Comment on this <a href="https://github.com/w3c/aria/issues/979">W3C tooltip issue</a> with thoughts, questions, and concerns to influence the future of expected tooltip behavior.</p>
<h3 id="code-samples">Code samples</h3>
<p>Here is a simple <a href="https://codepen.io/smhigley/pen/KjoerX">Codepen example</a>, also viewable without the code editors as a <a href="https://s.codepen.io/smhigley/debug/KjoerX">full page pen</a>. Scott O'Hara also has a much more comprehensive, documented <a href="https://github.com/scottaohara/a11y_tooltips">example on github</a>.</p>
<h2 id="further-reading%3A">Further reading:</h2>
<ul>
<li><a href="https://www.24a11y.com/2017/the-trials-and-tribulations-of-the-title-attribute/">www.24a11y.com/2017/the-trials-and-tribulations-of-the-title-attribute</a></li>
<li><a href="https://ebay.gitbook.io/mindpatterns/disclosure/tooltip">ebay.gitbook.io/mindpatterns/disclosure/tooltip</a></li>
<li><a href="https://inclusive-components.design/tooltips-toggletips/">inclusive-components.design/tooltips-toggletips</a></li>
<li><a href="https://a11yproject.com/posts/title-attributes/">a11yproject.com/posts/title-attributes</a></li>
<li><a href="https://developer.paciellogroup.com/blog/2013/01/using-the-html-title-attribute-updated/">developer.paciellogroup.com/blog/2013/01/using-the-html-title-attribute-updated</a></li>
</ul>

    ]]></content>
  </entry>
	
  
  <entry>
    <title>Escaping 101</title>
    <link href="https://sarahmhigley.com/writing/escaping-101/"/>
    <updated>2019-10-10T19:00:00-05:00</updated>
    <id>https://sarahmhigley.com/writing/escaping-101/</id>
    <content type="html"><![CDATA[
      <p>Earlier this week when filling out an expense report -- a tedious chore that nearly everyone wishes would be over roughly five minutes before starting -- I got about halfway through before inadvertently deleting all my progress and forcing myself to start over.</p>
<p>Why? I had used the escape key to collapse a select menu, and ended up closing the modal dialog containing the entire expense form instead. This happened because the select menu really should have been a <code>&lt;select&gt;</code>, but wasn't. Instead it was a custom dropdown, and whoever made it remembered that dropdowns should dismiss on escape, but didn't test that behavior in context. So of course, being an a11y-focused developer, my immediate response was to put off finishing the expense report and start writing a blog post about the escape key instead.</p>
<h2 id="why-escape%3F">Why escape?</h2>
<p>When starting out on the long, pothole-ridden journey to better keyboard accessibility, the three most common pit stops along the road (the Shell, BP, and Chevron, if you will) are Enter/Space, arrow keys, and escape. There are other keys, of course -- Home, End, PageUp, PageDown all make appearances as the occasional drive-through coffee stand or 2am IHOP.</p>
<p>Then there are <a href="https://webaim.org/techniques/keyboard/accesskey">accesskeys</a>, the weird roadside attractions of accessibility: you periodically see signs for them, but almost never actually visit. In the general run of things, however, a developer working on custom keyboard handling for the web will generally spend the most time on these keys:</p>
<ul>
<li><a href="https://marcysutton.com/links-vs-buttons-in-modern-web-applications">Enter or Space</a>: perform the primary action of the control.</li>
<li>Arrow keys: move focus to the previous or next control, when appropriate.</li>
<li>Escape: exit the current context.</li>
</ul>
<p>Enter, Space, and arrow keys are all fairly predictable. By that I mean it is very rare to encounter uncertainty from either the developer or the user around what should happen when the spacebar is pressed.</p>
<p>...and please don't come at me with your split buttons or selectable editable tree items, write your own article ;)</p>
<p>This is a slight oversimplification, but: some combination of enter and space perform the primary action of the currently focused control, and arrow keys shift focus in one or two dimensions.</p>
<p>Escape, on the other hand, is a little trickier. It has become an all-purpose &quot;get me out of here!&quot; key; something like <code>array.pop()</code> but for UI contexts.</p>
<h2 id="when-should-you-escape%3F">When should you escape?</h2>
<p>(Or: what do I mean when I say &quot;UI context&quot;?)</p>
<h3 id="part-1%3A-overlays">Part 1: Overlays</h3>
<p>In its simplest incarnation, a new context is created when an overlay opens and fully or partially covers some other stuff (technical term) in the same window. When this happens, escape should allow the user to return to their previously un-obscured view. Almost all of the definitions of escape-based interactions in the <a href="https://www.w3.org/TR/wai-aria-practices-1.1/">Aria Authoring Practices</a> fall in this bucket:</p>
<ul>
<li><a href="https://www.w3.org/TR/wai-aria-practices-1.1/#combobox">Combobox</a></li>
<li><a href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal">Modal dialog</a></li>
<li><a href="https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton">Menu</a></li>
<li><a href="https://www.w3.org/TR/wai-aria-practices-1.1/#tooltip">Tooltip</a></li>
</ul>
<p>A few more overlays you may find yourself needing to escape from:</p>
<ul>
<li>Slidepanes</li>
<li>Non-modal dialogs (e.g. <a href="https://www.w3.org/TR/wai-aria-practices-1.1/examples/disclosure/disclosure-navigation.html">disclosure buttons with popups</a>)</li>
<li>Custom context menus</li>
</ul>
<p>Generally overlays are pretty easy to recognize. Anything that appears on top of the regular flow of the document, whether <a href="https://www.nngroup.com/articles/modal-nonmodal-dialog/">modal or non-modal</a>, interactive or not, counts as an overlay and should be easy to dismiss. See the <a href="https://www.w3.org/WAI/WCAG21/Understanding/content-on-hover-or-focus.html">WCAG 2.1 content on hover or focus</a> criterion, or my earlier <a href="https://sarahmhigley.com/writing/tooltips-in-wcag-21/">long tooltip <s>ant</s> article</a> for more context on why.</p>
<h3 id="part-2%3A-tab-traps">Part 2: Tab traps</h3>
<p>The most common example of a tab trap was already covered in the previous section -- the modal dialog. However, there are other examples of UI elements that block tabbing without visually breaking the page flow:</p>
<ul>
<li>A rich text editor or code editor: tabbing within these inserts an actual tab character, so there needs to be another way of exiting and moving past them.</li>
<li>Too many tab stops: counter-intuitively, too many focusable items can also effectively block keyboard navigation. Imagine a table with 50 rows and a few interactive items per row; it would take a lot of patience to get through 100+ tab stops. A <a href="https://a11yproject.com/posts/skip-nav-links/">skip link</a> at the beginning would help someone who wants to bypass the table entirely, but not someone who wants to browse through the table's data and then either return to the beginning of the table (maybe there are filters or other controls there), or skip past remaining rows.</li>
</ul>
<h3 id="part-3%3A-cancel-changes">Part 3: Cancel changes</h3>
<p>This category of escapable contexts has nothing to do with page navigation, and everything to do with editing content. Any interface that allows the user to switch between reading and editing (like a cell within an editable grid) should provide the option to cancel all changes and return to the read mode at any point when editing.</p>
<p>If edit mode vs. read mode is a full page change (for example, the github gist editor), then a cancel button makes more sense than escape for switching back to read mode. However, for in-place edits (for example, changing a single cell within an editable grid) it makes sense to allow the user to hit escape to cancel and return to read mode.</p>
<h2 id="so-you've-escaped.-now-what%3F">So you've escaped. Now what?</h2>
<p>(Or: where should focus go next?)</p>
<p>Some popups like combobox menus and tooltips never take focus, so no active focus handling needs to occur when they are dismissed.</p>
<p>Other popups should take focus when opened -- modal dialogs, modal slidepanes, some menus -- and should send focus back to the element that originally opened the popup when closed. If that element no longer exists, it gets a bit trickier. The ARIA Authoring Practices Guide has a <a href="https://www.w3.org/TR/wai-aria-practices-1.1/#h-note-7">long note on focus handling when closing modals</a>. The short version is: take a second to think about where the user would expect to be, and send focus there.</p>
<blockquote>
<p><img src="/writing/assets/nope-octopus.jpg" alt="still frame of the nope octopus meme"><br>
Start by putting yourself in your users' frame of mind</p>
</blockquote>
<p>It's also possible to put focus in different places depending on how a modal is closed: for example, a modal form that creates a new table row may move focus to that row when submitted. Even if this type of logic exists, closing via escape should take the user back to the original trigger button.</p>
<p>Our third category, non-modal tab traps, are a little harder. Escape should jump the user out of the tab trap but there's no obvious place to put focus, and the user shouldn't end up immediately re-entering the tab trap on the next tab or shift + tab. There's no way of knowing whether the user intends to move forwards or backwards after exiting, so you can't simply place focus before or after the trap. Combining escape with a skip link can be a powerful workaround, which is what this <a href="https://www-nzgzcsougj.now.sh/studies/grid/simple-actions">grid example</a> does.</p>
<h2 id="handling-conflicts-when-escaping">Handling conflicts when escaping</h2>
<p>(stopPropagation: Just Do It™)</p>
<p>When handling escape key event listeners within an application, it's important to always stop the event from propagating. This prevents multiple nested components from all trying to respond to the same escape, so a user trying to dismiss a toolitp or combobox menu within a modal won't accidentally close the modal (thus bringing us back to the original modal that kicked all this off). A well-placed <code>event.stopPropagation()</code> would have prevented that original bug.</p>
<p>A good rule of thumb when coding UI components is if you ever write a listener for a key event and do anything at all in response to the escape key, then also stop event propagation.</p>
<p>Example:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="highlight-line">myCombobox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'keydown'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token string">'Escape'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">    myCombobox<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line">    event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  <span class="token punctuation">}</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre>
<h3 id="external-conflicts">External conflicts</h3>
<p>It's uncommon for web apps or websites to ever run into a situation where custom escape handling might iinterfere with native platform behavior, but when testing with Windows screen readers it's good to know that the first escape press might cause a switch from <a href="https://tink.uk/understanding-screen-reader-interaction-modes/">application mode to browse mode</a>. If this happens, the event may or may not be sent to the DOM as well -- NVDA does not send a keyboard event to the DOM when switching modes, but JAWS does. This is worth remembering, since it is entirely possible for a JAWS user to accidentally dismiss a popup when intending to switch modes. The only real workaround to this is to make escaped contexts easily recoverable -- modals and dropdowns can be re-opened, and tab traps can be re-entered. Ideally something like a modal form would either save user input if closed and re-opened or, even better, live within its own separate page.</p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>Escape has been used to do some weird things in native applications. In Internet Explorer, escape will clear a text input; same in Microsoft Outlook for Windows and File Explorer. Browser URL bars in Windows and MacOS will not only clear input but also restore the current URL on escape. On Windows, escape lets you exit the application menu and takes you back to whatever last had focus. Pressing escape in the chat window of Microsoft Teams jumps you to the most recent message. And there are certainly more escape oddities out there, waiting to be discovered.</p>
<p>While many of those seem uninituitive to me, they may make sense to someone else. When venturing off the beaten path of documented patterns and simple escape behavior, the ultimate test is always a well-rounded usability study and real-world feedback.</p>
<p>In the meantime, check out <a href="https://www-nzgzcsougj.now.sh/studies/grid/simple-actions">the grid example page</a> for a practical example containing several different uses of escape.</p>
<p>Now to finish that expense report...</p>

    ]]></content>
  </entry>
	
  
  <entry>
    <title>Playing with state</title>
    <link href="https://sarahmhigley.com/writing/playing-with-state/"/>
    <updated>2019-11-03T18:00:00-06:00</updated>
    <id>https://sarahmhigley.com/writing/playing-with-state/</id>
    <content type="html"><![CDATA[
      <p>In an effort to convince everyone (who reads these blog posts) that I don't only obsess over tooltips, let's talk about another seemingly simple concept and make it unexpectedly complex. This time, we're tackling the play/pause toggle button.</p>
<p>By a play/pause toggle, I mean this thing:</p>
<p><img src="https://user-images.githubusercontent.com/3819570/67927236-ff256480-fbaf-11e9-8aec-55a4353bfe5b.jpg" alt="Screenshot of the youtube player with the play button highlighted. Maru is staring at a box in the backgroud."></p>
<p>i.e. that thing you click on (or key press/touch/switch/etc) to get your daily cute cat fix. You press it, it switches from a play icon to a pause icon, Maru jumps into a box, and bliss ensues.</p>
<p>That's where I barge in and ask about that middle part -- switching from play to pause -- and ruin it all (sorry Maru). The thing is, a play/pause button is effectively a <a href="https://inclusive-components.design/toggle-button/">toggle button</a>, by which I mean it switches between two binary states based on user interaction. The established pattern for accomplishing this is by updating the <code>aria-pressed</code> state attribute, which accepts a true/false value.</p>
<p><img src="https://user-images.githubusercontent.com/3819570/67974752-ded6c380-fc0a-11e9-98a4-5024af40d294.png" alt="two side by side bookmark buttons, one grey with aria-pressed set to false, and one blue with aria-pressed set to true"></p>
<p>Play/pause buttons (and by extension, start/stop buttons) are the black sheep of the toggle button family. They generally do not have any <code>aria-pressed</code> on/off state defined, and instead change their accessible name from &quot;play&quot; to &quot;pause&quot; when activated. When I say &quot;generally,&quot; I mean this was true for the following sites, chosen for no formal reason other than that I happened to know they would contain media players:</p>
<ul>
<li><a href="https://www.youtube.com/">Youtube</a>: dynamically changes <code>aria-label</code></li>
<li><a href="https://mixer.com/">Mixer</a>: dynamically changes <code>aria-label</code></li>
<li><a href="https://vimeo.com/">Vimeo</a>: dynamically changes name from contents (by swapping out labelled graphics)</li>
<li><a href="https://soundcloud.com/">Soundcloud</a>: dynamically changes both text content and the <code>title</code> attribute</li>
<li><a href="https://www.w3.org/WAI/tutorials/carousels/working-example/">WAI carousel tutorial</a>: dynamically changes text content</li>
<li><s>Twitter's media player</s>: Twitter's media player actually has no accessible name and no state defined for its play button. Whoops.</li>
</ul>
<p>So why does this matter? Traditional toggle buttons switch <code>aria-pressed</code> from true to false, and play/pause buttons change their calculated name from &quot;play&quot; to &quot;pause.&quot; No big deal?</p>
<h2 id="property-vs.-state">Property vs. State</h2>
<p>Most dynamic changes to a UI component (at least, changes that happen while a user is interacting with it) are communicated through state changes rather than property changes. The ARIA spec has this to say about <a href="https://www.w3.org/WAI/PF/aria/states_and_properties#statevsprop">states vs. properties</a>:</p>
<blockquote>
<p>One major difference is that the values of properties (such as aria-labelledby) are often less likely to change throughout the application life-cycle than the values of states (such as aria-checked) which may change frequently due to user interaction. Note that the frequency of change difference is not a rule; a few properties, such as aria-activedescendant, aria-valuenow, and aria-valuetext are expected to change often.</p>
</blockquote>
<p>This comes across as fairly similar to the use of states vs. properties in javascript application frameworks as well -- a common convention is that a change in application state will trigger a re-render, while a change to a property will not (unless manually triggered).</p>
<p>It might therefore seem reasonable to also expect a screen reader to pick up and announce state changes but not property changes. However, as with many things related to ARIA, it is not that simple.</p>
<p>Some properties such as <code>aria-activedescendant</code>, <code>aria-valuenow</code>, and <code>aria-valuetext</code> can be expected to be announced by screen readers when changed (support issues aside). Some state changes (such as <code>aria-disabled</code>) are not consistently announced when changed. However, as a very general rule of thumb, it is safer to assume that a change in state will be communicated than a change in property (and please never change a role during a user interaction).</p>
<p>Side note: when I reference changes that are announced by screen readers, I mean a change to the element that currently has focus that causes some sort of screen reader-generated feedback without the user moving focus.</p>
<p>Most screen readers nowadays rely on <a href="https://alistapart.com/article/semantics-to-screen-readers/">Accessibility API</a> events to get notifications about changes to the DOM. So, for example, when <code>aria-pressed</code> updates from <code>true</code> to <code>false</code> a <code>PropertyChangedEvent</code> will fire, allowing a screen reader to listen to that event and react to it. Each platform's Accessibility API handles this slightly differently (<code>PropertyChangedEvent</code> is specific to <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/entry-uiauto-win32">UIA</a> on Windows), but the principal is roughly the same. This <a href="https://w3c.github.io/core-aam/#mapping_events_state-change">list of state and property change events</a> details which states and properties should raise API events when changed. Not all of those states and properties will necessarily be communicated by all screen readers, but these are the ones that at least have a mechanism to do so.</p>
<p>All this is relevant since <code>aria-pressed</code> is a state, and the accessible name is a property.</p>
<h2 id="name-changes">Name Changes</h2>
<p>The conventional wisdom is to not change the name of a control while the user is interacting with it. It turns out this is pretty good conventional wisdom: upon testing, I found that while a name change is sometimes announced, it is not nearly consistent enough to be relied upon.</p>
<p>Using this <a href="https://jsfiddle.net/czsnj9xp/show">button code sample</a>, I tested whether name changes and <code>aria-pressed</code> changes were announced using the following screen reader/browser combinations, and using a few different methods of defining the accessible name:</p>
<table class="support-table">
  <thead>
    <tr>
      <th></th>
      <th scope="col"><code>aria-label</code></th>
      <th scope="col"><code>aria-labelledby</code></th>
      <th scope="col">content</th>
      <th scope="col"><code>aria-pressed</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">NVDA + Firefox</th>
      <td class="true">yes</td>
      <td class="false">no</td>
      <td class="false">no</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">NVDA + Chrome</th>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="false">no</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">NVDA + Edge</th>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">JAWS + Firefox</th>
      <td class="false">no</td>
      <td class="false">no</td>
      <td class="false">no</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">JAWS + Chrome</th>
      <td class="false">no</td>
      <td class="false">no</td>
      <td class="false">no</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">JAWS + Edge</th>
      <td class="false">no</td>
      <td class="false">no</td>
      <td class="false">no</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">JAWS + IE 11</th>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">Narrator + Edge</th>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">iOS VoiceOver + Safari</th>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">macOS VoiceOver + Safari</th>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
      <td class="true">yes</td>
    </tr>
    <tr>
      <th scope="row">Talkback + Chrome</th>
      <td class="false">no</td>
      <td class="false">no</td>
      <td class="false">no</td>
      <td class="true">yes</td>
    </tr>
  </tbody>
</table>
<p>Side note: NVDA, you drunk?</p>
<h2 id="actual-recommendations">Actual Recommendations</h2>
<p>You made it this far, congratulations! Time for some concrete recommendations. The big takeaway should be this:</p>
<p><strong>Change the name, but not the state, of play/pause buttons. Use state for all other toggle buttons.</strong></p>
<p>Why? First, because the mechanics of a play/pause (or start/stop) button are so well understood by now that immediate state change feedback is not critical.</p>
<p>This is combined with the fact that using <code>aria-pressed=&quot;false&quot;</code> for a pause button would result in some variation of &quot;play button off&quot; to be read by screen readers, which is not particularly reflective of a visual pause icon. Creating a difference between the programmatic label and visual text (or icon) can cause issues for speech control users, sighted screen reader users, and effective communication between blind screen reader users and visual users (e.g. during a support call).</p>
<p>This one edge case does not take away the general recommendation to change the <code>aria-pressed</code> state, and not the name, for other toggle buttons. Toggle buttons that are part of less well-known interfaces would benefit more from providing immediate feedback, and the only reliable cross-screen-reader cross-browser way to do that is to use <code>aria-pressed</code>.</p>
<p>As a final note, never change both the name and <code>aria-pressed</code> state in tandem. That way, confusion lies. Just imagine trying to parse the meaning of &quot;play button, on&quot; vs. &quot;pause button, off&quot;.</p>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><a href="https://scottaohara.github.io/a11y_styled_form_controls/src/toggle-button-switch/">Styled Toggle Buttons</a> from Scott O'Hara</li>
<li><a href="https://www.smashingmagazine.com/2017/09/building-inclusive-toggle-buttons/">Building Inclusive Toggle Buttons</a> from Heydon Pickering</li>
<li><a href="https://docs.microsoft.com/en-us/windows/uwp/design/controls-and-patterns/toggles">UWP Toggle Switch description</a>: a Windows desktop toggle pattern, for reference</li>
</ul>

    ]]></content>
  </entry>
	
</feed>